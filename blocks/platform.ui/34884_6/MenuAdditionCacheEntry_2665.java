
package org.eclipse.ui.internal.menus;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import org.eclipse.core.commands.Category;
import org.eclipse.core.commands.Command;
import org.eclipse.core.commands.IHandler;
import org.eclipse.core.commands.ParameterizedCommand;
import org.eclipse.core.commands.State;
import org.eclipse.core.expressions.Expression;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IRegistryChangeEvent;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.LegacyActionTools;
import org.eclipse.jface.commands.RadioState;
import org.eclipse.jface.commands.ToggleState;
import org.eclipse.jface.menus.IMenuStateIds;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.SelectionEnabler;
import org.eclipse.ui.commands.ICommandService;
import org.eclipse.ui.handlers.IHandlerActivation;
import org.eclipse.ui.handlers.IHandlerService;
import org.eclipse.ui.internal.WorkbenchMessages;
import org.eclipse.ui.internal.WorkbenchPlugin;
import org.eclipse.ui.internal.expressions.LegacyActionSetExpression;
import org.eclipse.ui.internal.expressions.LegacyEditorContributionExpression;
import org.eclipse.ui.internal.expressions.LegacySelectionEnablerWrapper;
import org.eclipse.ui.internal.expressions.LegacyViewContributionExpression;
import org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy;
import org.eclipse.ui.internal.handlers.IActionCommandMappingService;
import org.eclipse.ui.internal.registry.IWorkbenchRegistryConstants;
import org.eclipse.ui.internal.services.RegistryPersistence;

public final class LegacyActionPersistence extends RegistryPersistence {

	private static final int INDEX_ACTION_SETS = 0;

	private static final int INDEX_EDITOR_CONTRIBUTIONS = INDEX_ACTION_SETS + 1;

	private static final int INDEX_VIEW_CONTRIBUTIONS = INDEX_EDITOR_CONTRIBUTIONS + 1;



	private final ICommandService commandService;

	private final Collection handlerActivations = new ArrayList();

	private final Collection menuContributions = new ArrayList();

	private final IWorkbenchWindow window;

	public LegacyActionPersistence(final IWorkbenchWindow window) {
		this.commandService = window
				.getService(ICommandService.class);
		this.window = window;
	}

	private final void clearActivations() {
		final IHandlerService service = window
				.getService(IHandlerService.class);
		if (service == null) {
			handlerActivations.clear();
			return;
		}
		service.deactivateHandlers(handlerActivations);
		final Iterator activationItr = handlerActivations.iterator();
		while (activationItr.hasNext()) {
			final IHandlerActivation activation = (IHandlerActivation) activationItr
					.next();
			final IHandler handler = activation.getHandler();
			if (handler != null) {
				handler.dispose();
			}
		}
		handlerActivations.clear();
	}

	private final void clearImages() {
	}

	private final void clearMenus() {
		menuContributions.clear();
	}

	private final ParameterizedCommand convertActionToCommand(
			final IConfigurationElement element, final String primaryId,
			final String secondaryId, final List warningsToLog) {
		String commandId = readOptional(element, ATT_DEFINITION_ID);
		Command command = null;
		if (commandId != null) {
			command = commandService.getCommand(commandId);
		}

		final IActionCommandMappingService mappingService = window
				.getService(IActionCommandMappingService.class);
		
		String label = null;
		if ((commandId == null) || (!command.isDefined())) {
			if (commandId == null && mappingService != null) {
				commandId = mappingService.getGeneratedCommandId(primaryId,
						secondaryId);
			}
			if (commandId == null) {
				WorkbenchPlugin.log("MappingService unavailable"); //$NON-NLS-1$
				return null;
			}

			label = readRequired(element, ATT_LABEL, warningsToLog,
					"Actions require a non-empty label or definitionId", //$NON-NLS-1$
					commandId);
			if (label == null) {
				label = WorkbenchMessages.LegacyActionPersistence_AutogeneratedCommandName;
			}

			final String tooltip = readOptional(element, ATT_TOOLTIP);

			command = commandService.getCommand(commandId);
			final Category category = commandService.getCategory(null);
			final String name = LegacyActionTools.removeAcceleratorText(Action
					.removeMnemonics(label));
			command.define(name, tooltip, category, null);

			final String style = readOptional(element, ATT_STYLE);
			if (STYLE_RADIO.equals(style)) {
				final State state = new RadioState();
				final boolean checked = readBoolean(element, ATT_STATE, false);
				state.setValue((checked) ? Boolean.TRUE : Boolean.FALSE);
				command.addState(IMenuStateIds.STYLE, state);

			} else if (STYLE_TOGGLE.equals(style)) {
				final State state = new ToggleState();
				final boolean checked = readBoolean(element, ATT_STATE, false);
				state.setValue((checked) ? Boolean.TRUE : Boolean.FALSE);
				command.addState(IMenuStateIds.STYLE, state);
			}
		}
		if (mappingService != null && commandId != null) {
			mappingService.map(mappingService.getGeneratedCommandId(primaryId,
					secondaryId), commandId);
		}

		return new ParameterizedCommand(command, null);
	}

	private final void convertActionToHandler(
			final IConfigurationElement element, final String actionId,
			final ParameterizedCommand command,
			final Expression activeWhenExpression, final String viewId,
			final List warningsToLog) {
		final boolean retarget = readBoolean(element, ATT_RETARGET, false);

		final boolean classAvailable = (element.getAttribute(ATT_CLASS) != null)
				|| (element.getChildren(TAG_CLASS).length != 0);
		String classString = readOptional(element, ATT_CLASS);
		if (classAvailable && classString == null) {
			classString = readOptional(element.getChildren(TAG_CLASS)[0],
					ATT_CLASS);
		}

		if (retarget) {
			if (classAvailable && !isPulldown(element)) {
				addWarning(warningsToLog,
						"The class was not null but retarget was set to true", //$NON-NLS-1$
						element, actionId, ATT_CLASS, classString);
			}

			final IActionCommandMappingService mappingService = window
					.getService(IActionCommandMappingService.class);
			if (mappingService != null) {
				mappingService.map(actionId, command.getId());
			} else {
				addWarning(
						warningsToLog,
						"Retarget service unavailable", //$NON-NLS-1$
						element, actionId);
			}
			return; // This is nothing more to be done.

		} else if (!classAvailable) {
			addWarning(
					warningsToLog,
					"There was no class provided, and the action is not retargettable", //$NON-NLS-1$
					element, actionId);
			return; // There is nothing to be done.
		}

		SelectionEnabler enabler = null;
		if (element.getAttribute(ATT_ENABLES_FOR) != null) {
			enabler = new SelectionEnabler(element);
		} else {
			IConfigurationElement[] kids = element.getChildren(TAG_ENABLEMENT);
			if (kids.length > 0) {
				enabler = new SelectionEnabler(element);
			}
		}
		final Expression enabledWhenExpression;
		if (enabler == null) {
			enabledWhenExpression = null;
		} else {
			enabledWhenExpression = new LegacySelectionEnablerWrapper(enabler,
					window);
		}

		final ActionDelegateHandlerProxy handler = new ActionDelegateHandlerProxy(
				element, ATT_CLASS, actionId, command, window, null,
				enabledWhenExpression, viewId);

		final String helpContextId = readOptional(element, ATT_HELP_CONTEXT_ID);
		if (helpContextId != null) {
			commandService.setHelpContextId(handler, helpContextId);
		}

		final String commandId = command.getId();
		final IHandlerService service = window
				.getService(IHandlerService.class);
		final IHandlerActivation handlerActivation;
		if (activeWhenExpression == null) {
			handlerActivation = service.activateHandler(commandId, handler);
		} else {
			handlerActivation = service.activateHandler(commandId, handler,
					activeWhenExpression);
		}
		handlerActivations.add(handlerActivation);
	}



	@Override
	public final void dispose() {
		super.dispose();
		clear();
	}

	private void clear() {
		clearActivations();
		clearImages();
		clearMenus();
	}

	@Override
	protected final boolean isChangeImportant(final IRegistryChangeEvent event) {
		return !((event.getExtensionDeltas(PlatformUI.PLUGIN_ID,
				IWorkbenchRegistryConstants.PL_ACTION_SETS).length == 0)
				&& (event.getExtensionDeltas(PlatformUI.PLUGIN_ID,
						IWorkbenchRegistryConstants.PL_EDITOR_ACTIONS).length == 0)
				&& (event.getExtensionDeltas(PlatformUI.PLUGIN_ID,
						IWorkbenchRegistryConstants.PL_POPUP_MENU).length == 0) && (event
				.getExtensionDeltas(PlatformUI.PLUGIN_ID,
						IWorkbenchRegistryConstants.PL_VIEW_ACTIONS).length == 0));
	}

	@Override
	public final void read() {
		clear();
		LegacyActionPersistence.super.read();

		final IExtensionRegistry registry = Platform.getExtensionRegistry();
		int actionSetCount = 0;
		int editorContributionCount = 0;
		int viewContributionCount = 0;
		final IConfigurationElement[][] indexedConfigurationElements = new IConfigurationElement[5][];

		final IConfigurationElement[] actionSetsExtensionPoint = registry
				.getConfigurationElementsFor(EXTENSION_ACTION_SETS);
		for (int i = 0; i < actionSetsExtensionPoint.length; i++) {
			final IConfigurationElement element = actionSetsExtensionPoint[i];
			final String name = element.getName();
			if (TAG_ACTION_SET.equals(name)) {
				addElementToIndexedArray(element, indexedConfigurationElements,
						INDEX_ACTION_SETS, actionSetCount++);
			}
		}

		final IConfigurationElement[] editorActionsExtensionPoint = registry
				.getConfigurationElementsFor(EXTENSION_EDITOR_ACTIONS);
		for (int i = 0; i < editorActionsExtensionPoint.length; i++) {
			final IConfigurationElement element = editorActionsExtensionPoint[i];
			final String name = element.getName();
			if (TAG_EDITOR_CONTRIBUTION.equals(name)) {
				addElementToIndexedArray(element, indexedConfigurationElements,
						INDEX_EDITOR_CONTRIBUTIONS, editorContributionCount++);
			}
		}

		final IConfigurationElement[] viewActionsExtensionPoint = registry
				.getConfigurationElementsFor(EXTENSION_VIEW_ACTIONS);
		for (int i = 0; i < viewActionsExtensionPoint.length; i++) {
			final IConfigurationElement element = viewActionsExtensionPoint[i];
			final String name = element.getName();
			if (TAG_VIEW_CONTRIBUTION.equals(name)) {
				addElementToIndexedArray(element, indexedConfigurationElements,
						INDEX_VIEW_CONTRIBUTIONS, viewContributionCount++);
			}
		}

		readActionSets(indexedConfigurationElements[INDEX_ACTION_SETS],
				actionSetCount);
		readEditorContributions(
				indexedConfigurationElements[INDEX_EDITOR_CONTRIBUTIONS],
				editorContributionCount);
		readViewContributions(
				indexedConfigurationElements[INDEX_VIEW_CONTRIBUTIONS],
				viewContributionCount);
		
	}

	private final void readActions(final String primaryId,
			final IConfigurationElement[] elements, final List warningsToLog,
			final Expression visibleWhenExpression, final String viewId) {
		for (int i = 0; i < elements.length; i++) {
			final IConfigurationElement element = elements[i];

			final String id = readRequired(element, ATT_ID, warningsToLog,
					"Actions require an id"); //$NON-NLS-1$
			if (id == null) {
				continue;
			}

			final ParameterizedCommand command = convertActionToCommand(
					element, primaryId, id, warningsToLog);
			if (command == null) {
				continue;
			}

			convertActionToHandler(element, id, command, visibleWhenExpression,
					viewId, warningsToLog);
		}
	}

	private final void readActionsAndMenus(
			final IConfigurationElement element, final String id,
			final List warningsToLog, 
			final Expression visibleWhenExpression, final String viewId) {

		final IConfigurationElement[] actionElements = element
				.getChildren(TAG_ACTION);
		readActions(id, actionElements,
				warningsToLog, visibleWhenExpression, viewId);

	}

	private final void readActionSets(
			final IConfigurationElement[] configurationElements,
			final int configurationElementCount) {

		final List warningsToLog = new ArrayList(1);

		for (int i = 0; i < configurationElementCount; i++) {
			final IConfigurationElement element = configurationElements[i];

			final String id = readRequired(element, ATT_ID, warningsToLog,
					"Action sets need an id"); //$NON-NLS-1$
			if (id == null) {
				continue;
			}

			final String label = readRequired(element, ATT_LABEL,
					warningsToLog, "Actions set need a label", //$NON-NLS-1$
					id);
			if (label == null) {
				continue;
			}

			final LegacyActionSetExpression expression = new LegacyActionSetExpression(
					id, window);


			readActionsAndMenus(element, id,
					warningsToLog, expression, null);
		}

		logWarnings(
				warningsToLog,
				"Warnings while parsing the action sets from the 'org.eclipse.ui.actionSets' extension point"); //$NON-NLS-1$
	}

	private final void readEditorContributions(
			final IConfigurationElement[] configurationElements,
			final int configurationElementCount) {
		final List warningsToLog = new ArrayList(1);

		for (int i = 0; i < configurationElementCount; i++) {
			final IConfigurationElement element = configurationElements[i];

			final String id = readRequired(element, ATT_ID, warningsToLog,
					"Editor contributions need an id"); //$NON-NLS-1$
			if (id == null) {
				continue;
			}

			final String targetId = readRequired(element, ATT_TARGET_ID,
					warningsToLog, "Editor contributions need a target id", id); //$NON-NLS-1$
			if (targetId == null) {
				continue;
			}
			final Expression visibleWhenExpression = new LegacyEditorContributionExpression(
					targetId, window);

			readActionsAndMenus(element, id, warningsToLog,
					visibleWhenExpression, null);
		}

		logWarnings(
				warningsToLog,
				"Warnings while parsing the editor contributions from the 'org.eclipse.ui.editorActions' extension point"); //$NON-NLS-1$
	}

	private final void readViewContributions(
			final IConfigurationElement[] configurationElements,
			final int configurationElementCount) {
		final List warningsToLog = new ArrayList(1);

		for (int i = 0; i < configurationElementCount; i++) {
			final IConfigurationElement element = configurationElements[i];

			final String id = readRequired(element, ATT_ID, warningsToLog,
					"View contributions need an id"); //$NON-NLS-1$
			if (id == null) {
				continue;
			}

			final String targetId = readRequired(element, ATT_TARGET_ID,
					warningsToLog, "View contributions need a target id", id); //$NON-NLS-1$
			if (targetId == null) {
				continue;
			}
			final Expression visibleWhenExpression = new LegacyViewContributionExpression(
					targetId, window);

			readActionsAndMenus(element, id, warningsToLog,
					visibleWhenExpression, targetId);
		}

		logWarnings(
				warningsToLog,
				"Warnings while parsing the view contributions from the 'org.eclipse.ui.viewActions' extension point"); //$NON-NLS-1$
	}
}
